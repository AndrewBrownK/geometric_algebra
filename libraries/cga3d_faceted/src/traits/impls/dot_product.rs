// Note on Operative Statistics:
// Operative Statistics are not a precise predictor of performance or performance comparisons.
// This is due to varying hardware capabilities and compiler optimizations.
// As always, where performance is a concern, there is no substitute for
// real measurements on real work-loads on real hardware.
// Disclaimer aside, enjoy the fun information =)
//
// Total Implementations: 3159
//
// Yes SIMD:   add/sub     mul     div
//  Minimum:         0       1       0
//   Median:         3       4       0
//  Average:         3       4       0
//  Maximum:        31      32       0
//
//  No SIMD:   add/sub     mul     div
//  Minimum:         0       1       0
//   Median:         3       4       0
//  Average:         3       4       0
//  Maximum:        31      32       0
impl std::ops::Div<DotProductInfix> for AntiCircleOnOrigin {
    type Output = DotProductInfixPartial<AntiCircleOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiLine> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<Dipole> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleAtInfinity> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleInversion> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<FlatPoint> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatPointAtInfinity> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorAtInfinity> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<MultiVector> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<VersorOdd> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiCircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiCircleRotor {
    type Output = DotProductInfixPartial<AntiCircleRotor>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<AntiLine> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<Dipole> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorOnOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<Scalar> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOdd> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiCircleRotorAligningOrigin {
    type Output = DotProductInfixPartial<AntiCircleRotorAligningOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<AntiLine> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<Dipole> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatPoint> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatPointAtInfinity> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorAtInfinity> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<MultiVector> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<Scalar> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOdd> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiCircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiCircleRotorAligningOriginAtInfinity {
    type Output = DotProductInfixPartial<AntiCircleRotorAligningOriginAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<AntiLine> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<Dipole> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleAtInfinity> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleAtOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversion> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<MultiVector> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<Scalar> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOdd> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiCircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiCircleRotorAtInfinity {
    type Output = DotProductInfixPartial<AntiCircleRotorAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<AntiLine> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<Dipole> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversion> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<Flector> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlectorOnOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<Scalar> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOdd> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiCircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[scalar] * other[scalar]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiCircleRotorOnOrigin {
    type Output = DotProductInfixPartial<AntiCircleRotorOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<AntiLine> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<Dipole> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleAtInfinity> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleInversion> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<FlatPoint> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatPointAtInfinity> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorAtInfinity> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<MultiVector> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<Scalar> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOdd> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiCircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiDipoleInversion {
    type Output = DotProductInfixPartial<AntiDipoleInversion>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<AntiFlector> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<AntiPlane> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<Circle> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<DualNum> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<Infinity> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<Line> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<LineAtInfinity> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<MysteryCircle> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<Origin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<RoundPointAtOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<VersorEven> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiDipoleInversionAtInfinity {
    type Output = DotProductInfixPartial<AntiDipoleInversionAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlector> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<AntiPlane> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<Circle> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<DualNum> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<Line> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<LineOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MotorOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<MysteryCircle> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<Origin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<RoundPointAtOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEven> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiDipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiDipoleInversionOnOrigin {
    type Output = DotProductInfixPartial<AntiDipoleInversionOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlatOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<AntiFlector> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiPlane> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<Circle> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleAtInfinity> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleRotor> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<Infinity> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<Line> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineAtInfinity> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<Motor> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<MultiVector> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<MysteryCircle> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryCircleRotor> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryVersorEven> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<RoundPoint> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<RoundPointAtOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEven> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiDipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiDipoleInversionOrthogonalOrigin {
    type Output = DotProductInfixPartial<AntiDipoleInversionOrthogonalOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e5] * self[e4])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<AntiFlatPoint> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<AntiFlector> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<AntiPlane> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<Circle> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<DualNum> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<Infinity> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<Line> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<LineAtInfinity> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineOnOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e5] * other[e4])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<MysteryCircle> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryVersorEven> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<NullCircleAtOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e5] * other[e4]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<Origin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e5] * other[e4]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<RoundPointAtOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e5] * other[e4]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<VersorEven> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e5] * other[e4])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e5] * other[e4])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e5] * other[e4])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e5] * other[e4])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiDipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e5] * other[e4])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e4] * other[e5]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiDipoleOnOrigin {
    type Output = DotProductInfixPartial<AntiDipoleOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<AntiFlector> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<Circle> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleAtInfinity> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleRotor> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<Line> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineAtInfinity> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<Motor> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorAtInfinity> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MultiVector> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<MysteryCircle> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryCircleRotor> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryVersorEven> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<VersorEven> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiDipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiDualNum {
    type Output = DotProductInfixPartial<AntiDualNum>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleRotor> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiDualNum> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiMotor> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1234] * other[e3215]) + (self[scalar] * other[scalar]));
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<DipoleInversion> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<Flector> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<FlectorAtInfinity> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<Horizon> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<MultiVector> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1234] * other[e3215]) + (self[scalar] * other[scalar]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<Plane> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<Scalar> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<Sphere> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<SphereAtOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<VersorOdd> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1234] * other[e3215]) + (self[scalar] * other[scalar]));
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1234] * other[e3215]) + (self[scalar] * other[scalar]));
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiDualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1234] * other[e3215]) + (self[scalar] * other[scalar]));
    }
}
impl std::ops::Div<DotProductInfix> for AntiFlatOrigin {
    type Output = DotProductInfixPartial<AntiFlatOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatOrigin> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlector> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<Circle> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleAtInfinity> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleRotor> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MultiVector> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryCircle> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryCircleRotor> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryVersorEven> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<VersorEven> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiFlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl std::ops::Div<DotProductInfix> for AntiFlatPoint {
    type Output = DotProductInfixPartial<AntiFlatPoint>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<Circle> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleAtInfinity> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleAtOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleOnOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleRotorOnOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<MultiVector> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryCircleRotor> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryVersorEven> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<NullCircleAtOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiFlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiFlector {
    type Output = DotProductInfixPartial<AntiFlector>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiPlane> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<Circle> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleAtInfinity> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleAtOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleOnOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleRotorOnOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<DualNum> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<MultiVector> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<MysteryCircle> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryCircleRotor> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryVersorEven> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<NullCircleAtOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<Origin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<RoundPointAtOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEven> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiFlector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiFlectorOnOrigin {
    type Output = DotProductInfixPartial<AntiFlectorOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatOrigin> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiPlane> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<Circle> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleAtInfinity> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleRotor> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MultiVector> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<MysteryCircle> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryCircleRotor> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryVersorEven> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<RoundPoint> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEven> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiFlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl std::ops::Div<DotProductInfix> for AntiLine {
    type Output = DotProductInfixPartial<AntiLine>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiLine> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<Dipole> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleAtInfinity> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleAtOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversion> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<MultiVector> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<NullDipoleAtOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOdd> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiLine {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiLineOnOrigin {
    type Output = DotProductInfixPartial<AntiLineOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLine> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<Dipole> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleAtInfinity> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversion> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MultiVector> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipole> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<VersorOdd> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiLineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl std::ops::Div<DotProductInfix> for AntiMotor {
    type Output = DotProductInfixPartial<AntiMotor>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1234] * self[e3215]) + (other[scalar] * self[scalar]));
    }
}
impl DotProduct<AntiLine> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<Dipole> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleAtInfinity> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleAtOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversion> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<MultiVector> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Scalar> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<Sphere> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereAtOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereOnOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<VersorOdd> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiMotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[scalar] * other[scalar])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiMotorOnOrigin {
    type Output = DotProductInfixPartial<AntiMotorOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiLine> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<Dipole> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleAtInfinity> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversion> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MultiVector> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<Scalar> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOdd> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiMotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiMysteryCircleRotor {
    type Output = DotProductInfixPartial<AntiMysteryCircleRotor>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiLine> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl DotProduct<Dipole> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<DipoleAtInfinity> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversion> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<DipoleOnOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<FlatOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<Flector> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlectorOnOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<Scalar> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOdd> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiMysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[scalar] * other[scalar]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for AntiMysteryDipoleInversion {
    type Output = DotProductInfixPartial<AntiMysteryDipoleInversion>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiPlane> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<Circle> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<CircleAtInfinity> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<CircleRotor> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Line> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<LineOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MotorOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircle> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<RoundPoint> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEven> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiMysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl std::ops::Div<DotProductInfix> for AntiPlane {
    type Output = DotProductInfixPartial<AntiPlane>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<AntiFlector> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlane> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<DualNum> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<MultiVector> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<MysteryVersorEven> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<Origin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<RoundPointAtOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEven> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenOnOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiPlane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e5] * other[e4]));
    }
}
impl std::ops::Div<DotProductInfix> for AntiPlaneOnOrigin {
    type Output = DotProductInfixPartial<AntiPlaneOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiFlector> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlane> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<MultiVector> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<MysteryVersorEven> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<RoundPoint> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEven> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiPlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl std::ops::Div<DotProductInfix> for AntiScalar {
    type Output = DotProductInfixPartial<AntiScalar>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiScalar> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotor> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotorAligningOrigin> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotorAtInfinity> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotorOnOrigin> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<DualNum> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<Motor> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<MotorOnOrigin> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<MultiVector> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<MysteryCircleRotor> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<MysteryVersorEven> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<VersorEven> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<VersorEvenOnOrigin> for AntiScalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl std::ops::Div<DotProductInfix> for AntiSphereOnOrigin {
    type Output = DotProductInfixPartial<AntiSphereOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiFlector> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlane> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<Infinity> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<Motor> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<MotorAtInfinity> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<MultiVector> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<MysteryVersorEven> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<RoundPoint> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<RoundPointAtOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEven> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<VersorEvenAligningOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEvenAtInfinity> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for AntiSphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl std::ops::Div<DotProductInfix> for AntiVersorEvenOnOrigin {
    type Output = DotProductInfixPartial<AntiVersorEvenOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiLine> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<Dipole> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleAtInfinity> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleInversion> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<FlatPoint> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatPointAtInfinity> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<Horizon> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<MultiVector> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<MysteryDipole> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<Plane> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<Scalar> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<Sphere> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<SphereAtOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<VersorOdd> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for AntiVersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for Circle {
    type Output = DotProductInfixPartial<Circle>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlector> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<Circle> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<Line> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<LineAtInfinity> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineOnOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorOnOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for Circle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for CircleAligningOrigin {
    type Output = DotProductInfixPartial<CircleAligningOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiFlatPoint> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Circle> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<Line> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<LineAtInfinity> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineOnOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorOnOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryVersorEven> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<NullCircleAtOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for CircleAtInfinity {
    type Output = DotProductInfixPartial<CircleAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlectorOnOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<Circle> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleOnOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<Line> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<LineOnOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MotorOnOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for CircleAtOrigin {
    type Output = DotProductInfixPartial<CircleAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiFlatPoint> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<Circle> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleAtOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<Line> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineAtInfinity> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<Motor> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorAtInfinity> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MultiVector> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for CircleOnOrigin {
    type Output = DotProductInfixPartial<CircleOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlatPoint> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Circle> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleOnOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleRotor> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Line> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<LineAtInfinity> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineOnOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorOnOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryVersorEven> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEven> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl std::ops::Div<DotProductInfix> for CircleOrthogonalOrigin {
    type Output = DotProductInfixPartial<CircleOrthogonalOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlector> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<Circle> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<Line> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineAtInfinity> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<Motor> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorAtInfinity> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MultiVector> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryCircleRotor> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<MysteryVersorEven> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl DotProduct<NullCircleAtOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for CircleRotor {
    type Output = DotProductInfixPartial<CircleRotor>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlector> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiScalar> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Circle> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<DualNum> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<Line> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<LineAtInfinity> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineOnOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorOnOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for CircleRotorAligningOrigin {
    type Output = DotProductInfixPartial<CircleRotorAligningOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiFlatPoint> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiScalar> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Circle> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<DualNum> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<Line> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<LineAtInfinity> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineOnOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorOnOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleRotorAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for CircleRotorAligningOriginAtInfinity {
    type Output = DotProductInfixPartial<CircleRotorAligningOriginAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiScalar> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Circle> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAtOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOnOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotor> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<DualNum> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<Line> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<LineOnOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleRotorAligningOriginAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl std::ops::Div<DotProductInfix> for CircleRotorAtInfinity {
    type Output = DotProductInfixPartial<CircleRotorAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlectorOnOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiScalar> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Circle> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOnOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<CircleRotor> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<DualNum> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<Line> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<LineOnOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleRotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for CircleRotorOnOrigin {
    type Output = DotProductInfixPartial<CircleRotorOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlatPoint> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiScalar> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Circle> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleOnOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotor> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<Line> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<LineAtInfinity> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<LineOnOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<MotorOnOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MultiVector> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircle> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEven> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for CircleRotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl std::ops::Div<DotProductInfix> for Dipole {
    type Output = DotProductInfixPartial<Dipole>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiLine> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<Dipole> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorOnOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOdd> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for Dipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleAligningOrigin {
    type Output = DotProductInfixPartial<DipoleAligningOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotor> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiLine> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMotor> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<Dipole> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorOnOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOdd> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleAtInfinity {
    type Output = DotProductInfixPartial<DipoleAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiLine> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotorOnOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<Dipole> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversion> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<Flector> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlectorOnOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOdd> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleAtOrigin {
    type Output = DotProductInfixPartial<DipoleAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotor> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiLine> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMotor> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<Dipole> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatPoint> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<MultiVector> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOdd> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleInversion {
    type Output = DotProductInfixPartial<DipoleInversion>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiLine> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<Horizon> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<MultiVector> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Plane> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<PlaneOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Sphere> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) + (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1234] * other[e3215]) + (self[e3215] * other[e1234]));
    }
}
impl DotProduct<SphereOnOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOdd> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleInversionAligningOrigin {
    type Output = DotProductInfixPartial<DipoleInversionAligningOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotor> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiDualNum> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiLine> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMotor> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<Horizon> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<MultiVector> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Plane> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<PlaneOnOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Sphere> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) + (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1234] * other[e3215]) + (self[e3215] * other[e1234]));
    }
}
impl DotProduct<SphereOnOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOdd> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleInversionAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleInversionAtInfinity {
    type Output = DotProductInfixPartial<DipoleInversionAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiLine> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotorOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversion> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<Flector> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MultiVector> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Plane> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<PlaneOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Sphere> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereOnOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOdd> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleInversionAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleInversionAtOrigin {
    type Output = DotProductInfixPartial<DipoleInversionAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotor> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiDualNum> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiLine> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMotor> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e3215] * other[e1234])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatPoint> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<Horizon> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<MultiVector> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e3215] * other[e1234])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Plane> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<Sphere> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]));
    }
}
impl DotProduct<SphereAtOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]));
    }
}
impl DotProduct<SphereOnOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<VersorOdd> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e3215] * other[e1234])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e3215] * other[e1234])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleInversionOnOrigin {
    type Output = DotProductInfixPartial<DipoleInversionOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleRotor> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiLine> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMotor> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Dipole> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversion> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<Horizon> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<MultiVector> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<Plane> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<PlaneOnOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Sphere> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<SphereOnOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<VersorOdd> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleInversionOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleInversionOrthogonalOrigin {
    type Output = DotProductInfixPartial<DipoleInversionOrthogonalOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiLine> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<FlatPoint> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<Horizon> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<MultiVector> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e3215] * other[e1234])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) + (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Plane> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<Sphere> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]));
    }
}
impl DotProduct<SphereAtOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]));
    }
}
impl DotProduct<SphereOnOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<VersorOdd> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e3215] * other[e1234])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleInversionOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e3215] * other[e1234])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DipoleOnOrigin {
    type Output = DotProductInfixPartial<DipoleOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleRotor> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiLine> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMotor> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Dipole> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversion> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorOnOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<VersorOdd> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl std::ops::Div<DotProductInfix> for DipoleOrthogonalOrigin {
    type Output = DotProductInfixPartial<DipoleOrthogonalOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiLine> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<Dipole> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<FlatPoint> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlatPointAtInfinity> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<Flector> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<FlectorAtInfinity> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<MultiVector> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<MysteryDipole> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl DotProduct<NullDipoleAtOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOdd> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for DipoleOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for DualNum {
    type Output = DotProductInfixPartial<DualNum>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiFlector> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiPlane> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiScalar> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotor> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotorAligningOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotorAtInfinity> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<CircleRotorOnOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<DualNum> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Infinity> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<Motor> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e12345] * other[e12345]));
    }
}
impl DotProduct<MotorAtInfinity> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<MotorOnOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<MultiVector> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e12345] * other[e12345]));
    }
}
impl DotProduct<MysteryCircleRotor> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<MysteryVersorEven> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<RoundPoint> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<RoundPointAtOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEven> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e12345] * other[e12345]));
    }
}
impl DotProduct<VersorEvenAligningOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e12345] * other[e12345]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e12345] * other[e12345]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEvenOnOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e12345] * other[e12345] * -1.0);
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for DualNum {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl std::ops::Div<DotProductInfix> for FlatOrigin {
    type Output = DotProductInfixPartial<FlatOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleRotor> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiMysteryCircleRotor> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Dipole> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAligningOrigin> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAtInfinity> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversion> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionAtInfinity> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionOnOrigin> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleOnOrigin> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatOrigin> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<Flector> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlectorOnOrigin> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipole> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipoleInversion> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryVersorOdd> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<VersorOdd> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<VersorOddAtInfinity> for FlatOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl std::ops::Div<DotProductInfix> for FlatPoint {
    type Output = DotProductInfixPartial<FlatPoint>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotor> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<Dipole> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAtOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversion> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionAtOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleOnOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<FlatOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Flector> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<FlectorOnOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipoleInversion> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryVersorOdd> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<NullDipoleAtOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOdd> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for FlatPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl std::ops::Div<DotProductInfix> for FlatPointAtInfinity {
    type Output = DotProductInfixPartial<FlatPointAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotor> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<Dipole> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleAligningOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleAtOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversion> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversionAtOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleOnOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<MultiVector> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleAtOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOdd> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for FlatPointAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl std::ops::Div<DotProductInfix> for Flector {
    type Output = DotProductInfixPartial<Flector>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotor> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiDualNum> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiMysteryCircleRotor> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAtOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversion> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<FlatOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Flector> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MultiVector> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipoleInversion> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Plane> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<PlaneOnOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Sphere> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereOnOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOdd> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for Flector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for FlectorAtInfinity {
    type Output = DotProductInfixPartial<FlectorAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotor> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<AntiDualNum> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleAligningOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleAtOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversion> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<MultiVector> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Sphere> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereAtOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereOnOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<VersorOdd> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for FlectorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for FlectorOnOrigin {
    type Output = DotProductInfixPartial<FlectorOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleRotor> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<AntiMysteryCircleRotor> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Dipole> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAligningOrigin> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAtInfinity> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversion> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatOrigin> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Flector> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MultiVector> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e45] * other[e45] * -1.0);
    }
}
impl DotProduct<MysteryDipoleInversion> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<Plane> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<PlaneOnOrigin> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Sphere> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<SphereOnOrigin> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<VersorOdd> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for FlectorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e45] * other[e45]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for Horizon {
    type Output = DotProductInfixPartial<Horizon>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDualNum> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversion> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversionAtOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversionOnOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<MultiVector> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<NullSphereAtOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<Sphere> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereAtOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereOnOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<VersorOdd> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for Horizon {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl std::ops::Div<DotProductInfix> for Infinity {
    type Output = DotProductInfixPartial<Infinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<DualNum> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<MultiVector> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<Origin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPointAtOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEven> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenAligningOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenAtOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenOnOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for Infinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl std::ops::Div<DotProductInfix> for Line {
    type Output = DotProductInfixPartial<Line>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Circle> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAtOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOnOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotor> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotorOnOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<Line> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<LineOnOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<Motor> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MotorOnOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryVersorEven> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<NullCircleAtOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for Line {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl std::ops::Div<DotProductInfix> for LineAtInfinity {
    type Output = DotProductInfixPartial<LineAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiDipoleOnOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<Circle> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleAligningOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleAtOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOnOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotor> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotorAligningOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotorOnOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<MultiVector> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullCircleAtOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEven> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenAligningOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for LineAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl std::ops::Div<DotProductInfix> for LineOnOrigin {
    type Output = DotProductInfixPartial<LineOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Circle> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAligningOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAtInfinity> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleOnOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotor> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotorAligningOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotorOnOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Line> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<LineOnOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MotorOnOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MultiVector> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircle> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryVersorEven> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEven> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenAligningOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for LineOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl std::ops::Div<DotProductInfix> for Motor {
    type Output = DotProductInfixPartial<Motor>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiScalar> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Circle> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAtOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOnOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotor> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e12345] * self[e12345]));
    }
}
impl DotProduct<Line> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<LineOnOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<MysteryCircle> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<Origin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPointAtOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEven> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e12345] * other[e12345])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for Motor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for MotorAtInfinity {
    type Output = DotProductInfixPartial<MotorAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Circle> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleAligningOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleAtOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOnOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotor> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotorAligningOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleRotorOnOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<DualNum> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<MultiVector> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<Origin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<RoundPointAtOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEven> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for MotorAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for MotorOnOrigin {
    type Output = DotProductInfixPartial<MotorOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiScalar> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Circle> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAligningOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAtInfinity> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleOnOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotor> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Line> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<LineOnOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryCircle> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEven> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for MotorOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for MultiVector {
    type Output = DotProductInfixPartial<MultiVector>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDipoleInversion> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e5] * self[e4])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiDualNum> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1234] * self[e3215]) + (other[scalar] * self[scalar]));
    }
}
impl DotProduct<AntiFlatOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlector> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiLine> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiPlane> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiScalar> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Circle> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<Dipole> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DualNum> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e12345] * self[e12345]));
    }
}
impl DotProduct<FlatOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<Flector> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<Horizon> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<Infinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Line> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<LineAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<LineOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       31       32        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar])
                + (other[e1] * self[e1])
                + (other[e2] * self[e2])
                + (other[e3] * self[e3])
                + (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e321] * self[e321])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e12345] * self[e12345])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4])
                - (other[e45] * self[e45])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryCircle> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e12345] * other[e12345]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryDipole> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) + (self[e321] * other[e321])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]));
    }
}
impl DotProduct<NullDipoleAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e15] * other[e41]) + (self[e25] * other[e42]) + (self[e35] * other[e43]) + (self[e3215] * other[e1234]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e5] * other[e4]) - (self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<Origin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<Plane> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<PlaneOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<RoundPoint> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<RoundPointAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<Scalar> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<Sphere> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) + (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1234] * other[e3215]) + (self[e3215] * other[e1234]));
    }
}
impl DotProduct<SphereOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorEven> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       15       16        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) + (self[e321] * other[e321])
                - (self[e12345] * other[e12345])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) + (self[e321] * other[e321])
                - (self[e12345] * other[e12345])
                - (self[e4] * other[e5])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e4] * other[e5])
                - (self[e5] * other[e4])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345])
                - (self[e5] * other[e4])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) + (self[e321] * other[e321])
                - (self[e4] * other[e5])
                - (self[e5] * other[e4])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412]),
        );
    }
}
impl DotProduct<VersorOdd> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       15       16        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar])
                + (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar])
                + (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for MultiVector {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar])
                + (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for MysteryCircle {
    type Output = DotProductInfixPartial<MysteryCircle>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleOnOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlectorOnOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<Circle> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAtInfinity> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<CircleRotor> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Line> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<LineOnOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<MotorOnOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<MultiVector> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<MysteryCircle> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEven> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for MysteryCircle {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl std::ops::Div<DotProductInfix> for MysteryCircleRotor {
    type Output = DotProductInfixPartial<MysteryCircleRotor>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleOnOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlectorOnOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiScalar> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Circle> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAtInfinity> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<CircleRotor> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Line> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<LineOnOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<MysteryCircle> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEven> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]) - (self[e12345] * other[e12345]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for MysteryCircleRotor {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e321] * other[e321]);
    }
}
impl std::ops::Div<DotProductInfix> for MysteryDipole {
    type Output = DotProductInfixPartial<MysteryDipole>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLine> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotorOnOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<Dipole> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAtInfinity> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversion> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionAtInfinity> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<DipoleOnOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<FlatOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Flector> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlectorOnOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<MultiVector> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<MysteryDipole> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOdd> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]) - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for MysteryDipole {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl std::ops::Div<DotProductInfix> for MysteryDipoleInversion {
    type Output = DotProductInfixPartial<MysteryDipoleInversion>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLine> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotorOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMysteryCircleRotor> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<Dipole> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAtInfinity> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversion> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<DipoleOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<FlatOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Flector> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MultiVector> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<Plane> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<PlaneOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Sphere> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<SphereOnOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<VersorOdd> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for MysteryDipoleInversion {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]));
    }
}
impl std::ops::Div<DotProductInfix> for MysteryVersorEven {
    type Output = DotProductInfixPartial<MysteryVersorEven>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiDipoleOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiPlane> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiScalar> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<Circle> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleAtInfinity> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<CircleRotor> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Line> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<LineOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<MysteryCircle> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<RoundPoint> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]));
    }
}
impl DotProduct<VersorEven> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) + (self[e321] * other[e321])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) + (self[e321] * other[e321])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345]) - (self[e415] * other[e415]) - (self[e425] * other[e425]) - (self[e435] * other[e435]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for MysteryVersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) + (self[e321] * other[e321]));
    }
}
impl std::ops::Div<DotProductInfix> for MysteryVersorOdd {
    type Output = DotProductInfixPartial<MysteryVersorOdd>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiCircleRotor> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiLine> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<Dipole> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleAtInfinity> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleInversion> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<DipoleOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<FlatOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Flector> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MultiVector> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<Plane> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<PlaneOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Scalar> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<Sphere> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<SphereOnOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<VersorOdd> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125])
                - (self[e45] * other[e45]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for MysteryVersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar]) + (self[e23] * other[e23]) + (self[e31] * other[e31]) + (self[e12] * other[e12]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for NullCircleAtOrigin {
    type Output = DotProductInfixPartial<NullCircleAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlatPoint> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<Circle> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleAligningOrigin> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleAtInfinity> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleAtOrigin> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotor> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorAligningOrigin> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<Line> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<LineAtInfinity> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<Motor> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<MotorAtInfinity> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<MultiVector> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<VersorEven> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenAligningOrigin> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for NullCircleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]));
    }
}
impl std::ops::Div<DotProductInfix> for NullDipoleAtOrigin {
    type Output = DotProductInfixPartial<NullDipoleAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleRotor> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiLine> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMotor> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<Dipole> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleAligningOrigin> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleAtInfinity> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleAtOrigin> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversion> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversionAtOrigin> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<FlatPoint> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<FlatPointAtInfinity> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<Flector> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<FlectorAtInfinity> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<MultiVector> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<VersorOdd> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<VersorOddAtInfinity> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for NullDipoleAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]));
    }
}
impl std::ops::Div<DotProductInfix> for NullDipoleInversionAtOrigin {
    type Output = DotProductInfixPartial<NullDipoleInversionAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleRotor> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiLine> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<AntiMotor> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<Dipole> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleAligningOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleAtInfinity> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleAtOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<DipoleInversion> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<FlatPoint> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<FlatPointAtInfinity> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<Flector> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<Horizon> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<MultiVector> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<Plane> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<Sphere> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<SphereAtOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<VersorOdd> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for NullDipoleInversionAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15]) + (self[e42] * other[e25]) + (self[e43] * other[e35]) + (self[e1234] * other[e3215]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for NullSphereAtOrigin {
    type Output = DotProductInfixPartial<NullSphereAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiMotor> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<DipoleInversion> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<DipoleInversionAtInfinity> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<DipoleInversionAtOrigin> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<Flector> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<FlectorAtInfinity> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<Horizon> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<MultiVector> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<Plane> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<Sphere> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<SphereAtOrigin> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<VersorOdd> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<VersorOddAtInfinity> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for NullSphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl std::ops::Div<DotProductInfix> for NullVersorEvenAtOrigin {
    type Output = DotProductInfixPartial<NullVersorEvenAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e5] * self[e4]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlatPoint> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiPlane> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Circle> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleAligningOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleAtInfinity> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleAtOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotor> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorAligningOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<Infinity> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Line> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<LineAtInfinity> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<Motor> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MultiVector> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e5] * self[e4]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<RoundPoint> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<RoundPointAtOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEven> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for NullVersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for Origin {
    type Output = DotProductInfixPartial<Origin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiFlector> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiPlane> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Infinity> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Motor> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<MotorAtInfinity> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<MultiVector> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<RoundPoint> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<RoundPointAtOrigin> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEven> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEvenAligningOrigin> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEvenAtInfinity> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEvenAtOrigin> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for Origin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl std::ops::Div<DotProductInfix> for Plane {
    type Output = DotProductInfixPartial<Plane>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDualNum> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversion> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<DipoleInversionAtOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversionOnOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<Flector> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<FlectorOnOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<MultiVector> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<MysteryVersorOdd> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<NullSphereAtOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<Plane> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<PlaneOnOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<Sphere> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<SphereOnOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOdd> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for Plane {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl std::ops::Div<DotProductInfix> for PlaneOnOrigin {
    type Output = DotProductInfixPartial<PlaneOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<DipoleInversion> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Flector> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<FlectorOnOrigin> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<MultiVector> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<MysteryDipoleInversion> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<MysteryVersorOdd> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Plane> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<PlaneOnOrigin> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Sphere> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<SphereOnOrigin> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<VersorOdd> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl DotProduct<VersorOddAtInfinity> for PlaneOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]));
    }
}
impl std::ops::Div<DotProductInfix> for RoundPoint {
    type Output = DotProductInfixPartial<RoundPoint>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e5] * self[e4]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<AntiFlector> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlane> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<DualNum> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Infinity> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Motor> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<MotorAtInfinity> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<MultiVector> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Origin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<RoundPoint> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<RoundPointAtOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<VersorEven> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]));
    }
}
impl DotProduct<VersorEvenAtOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for RoundPoint {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) - (self[e4] * other[e5]) - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for RoundPointAtOrigin {
    type Output = DotProductInfixPartial<RoundPointAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e5] * self[e4]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<AntiFlector> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiPlane> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<DualNum> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Infinity> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Motor> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<MotorAtInfinity> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<MultiVector> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Origin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<RoundPoint> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<RoundPointAtOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<VersorEven> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<VersorEvenAligningOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<VersorEvenAtInfinity> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e4] * other[e5] * -1.0);
    }
}
impl DotProduct<VersorEvenAtOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl DotProduct<VersorEvenOnOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e5] * other[e4] * -1.0);
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for RoundPointAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(self[e4] * other[e5]) - (self[e5] * other[e4]));
    }
}
impl std::ops::Div<DotProductInfix> for Scalar {
    type Output = DotProductInfixPartial<Scalar>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleRotor> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiDualNum> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiMotor> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiMotorOnOrigin> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiMysteryCircleRotor> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<MultiVector> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<MysteryVersorOdd> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<Scalar> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<VersorOdd> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOddAtInfinity> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for Scalar {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[scalar] * other[scalar]);
    }
}
impl std::ops::Div<DotProductInfix> for Sphere {
    type Output = DotProductInfixPartial<Sphere>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDualNum> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiMotor> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversion> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) + (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) + (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<Flector> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<FlectorOnOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Horizon> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<MultiVector> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) + (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<MysteryVersorOdd> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<NullSphereAtOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<Plane> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<PlaneOnOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Sphere> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]));
    }
}
impl DotProduct<SphereOnOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOdd> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for Sphere {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]));
    }
}
impl std::ops::Div<DotProductInfix> for SphereAtOrigin {
    type Output = DotProductInfixPartial<SphereAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDualNum> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<AntiMotor> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversion> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1234] * self[e3215]) + (other[e3215] * self[e1234]));
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1234] * self[e3215]) + (other[e3215] * self[e1234]));
    }
}
impl DotProduct<DipoleInversionAtInfinity> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<DipoleInversionAtOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<DipoleInversionOnOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<Flector> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<FlectorAtInfinity> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<Horizon> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<MultiVector> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1234] * self[e3215]) + (other[e3215] * self[e1234]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<NullSphereAtOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<Plane> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<Sphere> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<SphereAtOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<SphereOnOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e3215] * other[e1234]);
    }
}
impl DotProduct<VersorOdd> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]));
    }
}
impl DotProduct<VersorOddAtInfinity> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for SphereAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (self[e3215] * other[e1234]) + (self[e1234] * other[e3215]));
    }
}
impl std::ops::Div<DotProductInfix> for SphereOnOrigin {
    type Output = DotProductInfixPartial<SphereOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiMotor> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<DipoleInversion> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<DipoleInversionOnOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<Flector> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<FlectorOnOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Horizon> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<MultiVector> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<MysteryVersorOdd> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Plane> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<PlaneOnOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Sphere> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<SphereOnOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<VersorOdd> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1234] * other[e3215]) - (self[e4235] * other[e4235]) - (self[e4315] * other[e4315]) - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for SphereOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ self[e1234] * other[e3215]);
    }
}
impl std::ops::Div<DotProductInfix> for VersorEven {
    type Output = DotProductInfixPartial<VersorEven>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e5] * self[e4])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlector> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiPlane> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiScalar> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<Circle> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e12345] * self[e12345]));
    }
}
impl DotProduct<Infinity> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Line> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<LineAtInfinity> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<LineOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       15       16        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e12345] * self[e12345])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<Origin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<RoundPoint> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<RoundPointAtOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<VersorEven> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       15       16        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for VersorEven {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e321] * other[e321]) + (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3])
                - (self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4])
                - (self[e4] * other[e5]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for VersorEvenAligningOrigin {
    type Output = DotProductInfixPartial<VersorEvenAligningOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e5] * self[e4])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiFlatPoint> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiPlane> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiScalar> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Circle> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e12345] * self[e12345]));
    }
}
impl DotProduct<Infinity> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Line> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<LineAtInfinity> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<LineOnOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<Origin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<RoundPoint> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<RoundPointAtOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<VersorEven> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e4] * self[e5])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e4] * other[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for VersorEvenAligningOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for VersorEvenAtInfinity {
    type Output = DotProductInfixPartial<VersorEvenAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlector> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiFlectorOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<AntiPlane> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiScalar> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<Circle> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<CircleOrthogonalOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<CircleRotor> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e12345] * self[e12345]));
    }
}
impl DotProduct<Line> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<LineOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e12345] * self[e12345])
                - (other[e4] * self[e5])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<MysteryCircle> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<MysteryCircleRotor> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<Origin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<RoundPoint> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<RoundPointAtOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<VersorEven> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e12345] * other[e12345])
                - (self[e415] * other[e415])
                - (self[e425] * other[e425])
                - (self[e435] * other[e435])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for VersorEvenAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e1] * other[e1]) + (self[e2] * other[e2]) + (self[e3] * other[e3]) + (self[e321] * other[e321])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for VersorEvenAtOrigin {
    type Output = DotProductInfixPartial<VersorEvenAtOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e5] * self[e4])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<AntiFlatPoint> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiPlane> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiSphereOnOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Circle> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleAtOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorOnOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<DualNum> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Infinity> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Line> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<LineAtInfinity> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<Motor> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MultiVector> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e4] * self[e5])
                - (other[e5] * self[e4])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<NullCircleAtOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<Origin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<RoundPoint> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<RoundPointAtOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<VersorEven> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e235] * other[e423]) - (self[e315] * other[e431]) - (self[e125] * other[e412]) - (self[e5] * other[e4]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for VersorEvenAtOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235])
                - (self[e431] * other[e315])
                - (self[e412] * other[e125])
                - (self[e4] * other[e5])
                - (self[e235] * other[e423])
                - (self[e315] * other[e431])
                - (self[e125] * other[e412])
                - (self[e5] * other[e4]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for VersorEvenOnOrigin {
    type Output = DotProductInfixPartial<VersorEvenOnOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e5] * self[e4])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlatPoint> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<AntiFlector> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<AntiPlane> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<AntiScalar> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: AntiScalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Circle> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleOnOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotor> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorAtInfinity> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<DualNum> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e12345] * self[e12345] * -1.0);
    }
}
impl DotProduct<Infinity> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Line> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<LineAtInfinity> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<LineOnOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<Motor> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e12345] * self[e12345])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorOnOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MultiVector> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345])
                - (other[e5] * self[e4])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]));
    }
}
impl DotProduct<MysteryCircleRotor> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]) - (other[e12345] * self[e12345]),
        );
    }
}
impl DotProduct<MysteryVersorEven> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<RoundPoint> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<RoundPointAtOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<VersorEven> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345])
                - (other[e415] * self[e415])
                - (other[e425] * self[e425])
                - (other[e435] * self[e435])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e12345] * self[e12345]) - (other[e415] * self[e415]) - (other[e425] * self[e425]) - (other[e435] * self[e435]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for VersorEvenOnOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(self[e423] * other[e235]) - (self[e431] * other[e315]) - (self[e412] * other[e125]) - (self[e4] * other[e5]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for VersorEvenOrthogonalOrigin {
    type Output = DotProductInfixPartial<VersorEvenOrthogonalOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiDipoleInversion> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: AntiDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionAtInfinity> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOnOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleInversionOrthogonalOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiDipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e5] * self[e4])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<AntiDipoleOnOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiDipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]),
        );
    }
}
impl DotProduct<AntiFlatOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: AntiFlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<AntiFlatPoint> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<AntiFlector> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiFlector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<AntiFlectorOnOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiFlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiMysteryDipoleInversion> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiPlane> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiPlane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<AntiPlaneOnOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiPlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]));
    }
}
impl DotProduct<AntiSphereOnOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiSphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]));
    }
}
impl DotProduct<Circle> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Circle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAligningOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtInfinity> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleAtOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleOnOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<CircleOrthogonalOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotor> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: CircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: CircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotorAligningOriginAtInfinity> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<CircleRotorAtInfinity> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: CircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) - (other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<CircleRotorOnOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: CircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<DualNum> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: DualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<Infinity> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Infinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e5] * self[e4] * -1.0);
    }
}
impl DotProduct<Line> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Line) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<LineAtInfinity> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: LineAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]));
    }
}
impl DotProduct<Motor> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Motor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MotorAtInfinity> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e235] * self[e423]) - (other[e315] * self[e431]) - (other[e125] * self[e412]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<MultiVector> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e4] * self[e5])
                - (other[e5] * self[e4])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412]),
        );
    }
}
impl DotProduct<MysteryCircle> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircle) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<MysteryCircleRotor> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: MysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e321] * self[e321]);
    }
}
impl DotProduct<MysteryVersorEven> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321]));
    }
}
impl DotProduct<NullCircleAtOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullCircleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]));
    }
}
impl DotProduct<NullVersorEvenAtOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullVersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<Origin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: Origin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e4] * self[e5] * -1.0);
    }
}
impl DotProduct<RoundPoint> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: RoundPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) - (other[e4] * self[e5]) - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<RoundPointAtOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: RoundPointAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4] * self[e5]) - (other[e5] * self[e4]));
    }
}
impl DotProduct<VersorEven> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEven) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4])
                - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<VersorEvenAligningOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtInfinity> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3]) + (other[e321] * self[e321])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenAtOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorEvenAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e4] * self[e5])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4]),
        );
    }
}
impl DotProduct<VersorEvenOnOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: VersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e423] * self[e235]) - (other[e431] * self[e315]) - (other[e412] * self[e125]) - (other[e4] * self[e5]),
        );
    }
}
impl DotProduct<VersorEvenOrthogonalOrigin> for VersorEvenOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorEvenOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e321] * self[e321]) + (other[e1] * self[e1]) + (other[e2] * self[e2]) + (other[e3] * self[e3])
                - (other[e423] * self[e235])
                - (other[e431] * self[e315])
                - (other[e412] * self[e125])
                - (other[e235] * self[e423])
                - (other[e315] * self[e431])
                - (other[e125] * self[e412])
                - (other[e5] * self[e4])
                - (other[e4] * self[e5]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for VersorOdd {
    type Output = DotProductInfixPartial<VersorOdd>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1234] * self[e3215]) + (other[scalar] * self[scalar]));
    }
}
impl DotProduct<AntiLine> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       14       15        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<FlatOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<FlatPointAtInfinity> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<Flector> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<Horizon> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<MultiVector> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       15       16        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar])
                + (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<Plane> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<PlaneOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Scalar> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<Sphere> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<SphereOnOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<VersorOdd> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       15       16        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e1234] * other[e3215])
                - (self[e45] * other[e45])
                - (self[e4235] * other[e4235])
                - (self[e4315] * other[e4315])
                - (self[e4125] * other[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for VersorOdd {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[e41] * other[e15])
                + (self[e42] * other[e25])
                + (self[e43] * other[e35])
                + (self[scalar] * other[scalar])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e1234] * other[e3215])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for VersorOddAtInfinity {
    type Output = DotProductInfixPartial<VersorOddAtInfinity>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1234] * self[e3215]) + (other[scalar] * self[scalar]));
    }
}
impl DotProduct<AntiLine> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiLineOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        4        5        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleInversion> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<FlatOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<FlatPoint> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        2        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e45] * self[e45] * -1.0);
    }
}
impl DotProduct<Flector> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<FlectorOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            -(other[e45] * self[e45]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MultiVector> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar])
                + (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryDipole> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<MysteryDipoleInversion> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<MysteryVersorOdd> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125])
                - (other[e45] * self[e45]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<Plane> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<PlaneOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: PlaneOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ -(other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]));
    }
}
impl DotProduct<Scalar> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<Sphere> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<SphereAtOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<SphereOnOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e1234] * self[e3215]) - (other[e4235] * self[e4235]) - (other[e4315] * self[e4315]) - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<VersorOdd> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12])
                - (other[e45] * self[e45])
                - (other[e4235] * self[e4235])
                - (other[e4315] * self[e4315])
                - (other[e4125] * self[e4125]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for VersorOddAtInfinity {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (self[scalar] * other[scalar])
                + (self[e15] * other[e41])
                + (self[e25] * other[e42])
                + (self[e35] * other[e43])
                + (self[e23] * other[e23])
                + (self[e31] * other[e31])
                + (self[e12] * other[e12])
                + (self[e3215] * other[e1234]),
        );
    }
}
impl std::ops::Div<DotProductInfix> for VersorOddOrthogonalOrigin {
    type Output = DotProductInfixPartial<VersorOddOrthogonalOrigin>;
    fn div(self, _rhs: DotProductInfix) -> Self::Output {
        DotProductInfixPartial(self)
    }
}
impl DotProduct<AntiCircleOnOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiCircleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiCircleRotor> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        9       10        0
    fn dot_product(self, other: AntiCircleRotorAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAligningOriginAtInfinity> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAligningOriginAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorAtInfinity> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiCircleRotorOnOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: AntiCircleRotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<AntiDualNum> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: AntiDualNum) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e1234] * self[e3215]) + (other[scalar] * self[scalar]));
    }
}
impl DotProduct<AntiLine> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: AntiLine) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<AntiLineOnOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: AntiLineOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<AntiMotor> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiMotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[scalar] * self[scalar])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<AntiMotorOnOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMotorOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiMysteryCircleRotor> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: AntiMysteryCircleRotor) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[scalar] * self[scalar]),
        );
    }
}
impl DotProduct<AntiVersorEvenOnOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: AntiVersorEvenOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<Dipole> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: Dipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAligningOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAtInfinity> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleAtOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        5        6        0
    fn dot_product(self, other: DipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<DipoleInversion> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAligningOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAligningOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtInfinity> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        6        7        0
    fn dot_product(self, other: DipoleInversionAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<DipoleInversionAtOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: DipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOnOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: DipoleInversionOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleInversionOrthogonalOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       10       11        0
    fn dot_product(self, other: DipoleInversionOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e3215] * self[e1234])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<DipoleOnOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: DipoleOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<DipoleOrthogonalOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        8        9        0
    fn dot_product(self, other: DipoleOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43]),
        );
    }
}
impl DotProduct<FlatPoint> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPoint) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<FlatPointAtInfinity> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: FlatPointAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]));
    }
}
impl DotProduct<Flector> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: Flector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<FlectorAtInfinity> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: FlectorAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e15] * self[e41]) + (other[e25] * self[e42]) + (other[e35] * self[e43]) + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<Horizon> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Horizon) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<MultiVector> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: MultiVector) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar])
                + (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<MysteryDipole> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipole) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<MysteryDipoleInversion> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: MysteryDipoleInversion) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]));
    }
}
impl DotProduct<MysteryVersorOdd> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: MysteryVersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar]) + (other[e23] * self[e23]) + (other[e31] * self[e31]) + (other[e12] * self[e12]),
        );
    }
}
impl DotProduct<NullDipoleAtOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        2        3        0
    fn dot_product(self, other: NullDipoleAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]));
    }
}
impl DotProduct<NullDipoleInversionAtOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        3        4        0
    fn dot_product(self, other: NullDipoleInversionAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15]) + (other[e42] * self[e25]) + (other[e43] * self[e35]) + (other[e1234] * self[e3215]),
        );
    }
}
impl DotProduct<NullSphereAtOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: NullSphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<Plane> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Plane) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e3215] * self[e1234]);
    }
}
impl DotProduct<Scalar> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: Scalar) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[scalar] * self[scalar]);
    }
}
impl DotProduct<Sphere> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: Sphere) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<SphereAtOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        1        2        0
    fn dot_product(self, other: SphereAtOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ (other[e3215] * self[e1234]) + (other[e1234] * self[e3215]));
    }
}
impl DotProduct<SphereOnOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        0        1        0
    fn dot_product(self, other: SphereOnOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(/* scalar */ other[e1234] * self[e3215]);
    }
}
impl DotProduct<VersorOdd> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorOdd) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<VersorOddAtInfinity> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32        7        8        0
    fn dot_product(self, other: VersorOddAtInfinity) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[scalar] * self[scalar])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e3215] * self[e1234]),
        );
    }
}
impl DotProduct<VersorOddOrthogonalOrigin> for VersorOddOrthogonalOrigin {
    // Operative Statistics for this implementation:
    //      add/sub      mul      div
    // f32       11       12        0
    fn dot_product(self, other: VersorOddOrthogonalOrigin) -> Scalar {
        use crate::elements::*;
        return Scalar::from_groups(
            // scalar
            (other[e41] * self[e15])
                + (other[e42] * self[e25])
                + (other[e43] * self[e35])
                + (other[scalar] * self[scalar])
                + (other[e23] * self[e23])
                + (other[e31] * self[e31])
                + (other[e12] * self[e12])
                + (other[e3215] * self[e1234])
                + (other[e15] * self[e41])
                + (other[e25] * self[e42])
                + (other[e35] * self[e43])
                + (other[e1234] * self[e3215]),
        );
    }
}
